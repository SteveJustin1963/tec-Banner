draft - convet/comment to 1.1


\\ Print out the top element of the stack as 8-bit binary number
\\ C prints out either 1 or 0}}

:C "        \\ dup
   (`1`)    \\ if positive print 1
   0=       \\ if 0
   (`0`)    \\ pint 0
   ;        \\ end			

\\ B tests each bit in turn and prints out 1 or 0 accordingly
:B 
   b!        \\ save b
   8(        \\ repeat 8 times
      128 b@ &  \\ #80 = b10000000  recall b  AND them, so keep msb
      128 =     \\ #80 = b10000000 = compare stack to msb if true
      C         \\ run C 
      b@ { b!   \\ recall b, shift number left (2*), save b
    )         \\ close loop
 ;         \\ end

\\ G emits either whitespace or blackspace (for chunky graphics).
:G
   "           \\ dup stack
   (           \\ loop if +ve
      219 \,      \\ print char 219, extended ascii block character â–ˆ
      )           \\ end loop
   0= (        \\ loop if = 0
      32 \,       \\ print char 32, ascii character SPACE
    )          \\ end loop
 ;
   
\\ A produces a row of chunky pixels followed by NEWLINE
:A 
   b!          \\ save b
   8(          \\ loop 8 times
      128 b@ &    \\ #80 = b10000000  recall b  AND them, so keep msb
      128 =       \\ #80 = b10000000 = compare stack to msb if true
      G           \\ run G
      b@ { b!     \\ recall b, shift number left (2*), save b 
      )        \\ close loop 
   \$          \\ CRLF
 ;		              

\\ Prints letter A
\$ #7E A #81 A #81 A #81 A #FF A #81 A #81 A #81 A    


\\ Prints letter B
\$ #FE A #81 A #81 A #FE A #81 A #81 A #81 A #FE A    

\\ Prints letter C
\$ #7E A #80 A #80 A #80 A #80 A #80 A #81 A #7E A    

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


Cut and paste this code into terminal to print chunky A B C

:G"(219 \,)0=(32 \,);
:A b! 8(128 b@ & 128 = G b@ { b!) \$;
\$ #7E A #81 A #81 A #FF A #81 A #81 A #81 A #00 A 
\$ #FE A #81 A #81 A #FE A #81 A #81 A #FE A #00 A
\$ #7E A #81 A #80 A #80 A #80 A #81 A #7E A #00 A

"BANANA BANDANA"  - a fun banner to print out on a terminal in chunky, 8x8 block graphics

First store the pixel patterns for  12 upper case alpha characters in byte arrays, define words G and P.
G prints out either a space (black) or an inverse space (white) character
P addresses the 8 bytes of the chosen array in turn and uses G to print a character 

\[#7E #81 #81 #FF #81 #81 #81 #00 ]  $a!   
\[#FE #81 #81 #FE #81 #81 #FE #00 ]  $b!
\[#7E #81 #80 #80 #80 #81 #7E #00 ]  $c!
\[#FE #81 #81 #81 #81 #81 #FE #00 ]  $d!
\[#FC #80 #80 #F8 #80 #80 #FC #00 ]  $e!
\[#FC #80 #80 #F8 #80 #80 #80 #00 ]  $f!
\[#FE #10 #10 #10 #10 #10 #FE #00 ]  $i!
\[#3C #42 #20 #18 #04 #42 #3C #00 ]  $s!
\[#FE #10 #10 #10 #10 #10 #10 #00 ]  $t!
\[#C3 #A5 #99 #81 #81 #81 #81 #00 ]  $m!  
\[#C1 #A1 #91 #89 #85 #83 #81 #00 ]  $n!
\[#00 #00 #00 #00 #00 #00 #00 #00 ]  $\s! 

:G"(219 \,)0=(32 \,);
:P @+\@ z! 8(128 z@ & 128 = G z@ { z!) 32 \,;
:M """mPiPnPtP\$;
:K """""""""""""bPaPnPaPnPaP\sPbPaPnPdPaPnPaP\$;
:B 8(\i@K);
:C 8(\i@M); 
C
B





\$ #7E A #81 A #81 A #FF A #81 A #81 A #81 A #00 A #FE A #81 A #81 A #FE A #81 A #81 A #FE A #00 A  #7E A #81 A #80 A #80 A #80 A #81 A #7E A #00 A

:E b! 3(4 b@ & 4 = G b@ { b!) \$;        This is a 3x5 font  only numbers 0 to 7 are needed 

7E 4E 6E 4E 7E     Print an E

7E 5E 4E 5E 7E     Print a C

3E 5E 4E 5E 3E 

7E 5E 6E 5E 7E    Print a B

